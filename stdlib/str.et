memory;

export {

    type Str = struct {
        data: String,
        size: Int,
    };


    of String -> Str fun mk_str raw_string;
    # Wraps a raw byte sequence into a string


    of Str -> String fun to_zero_terminated span;
    # Copies the string and terminates it with '\0'


    of Str -> Int fun strlen str;
    # Returns the length of a string excluding the last byte '\0'


    of Str -> Int -> Str fun cut_prefix str skip;
    # Returns a substring of str without first `skip` bytes;
    # the final length is >= 0

    of *Str -> Unit fun print_str;

    of Str -> Int -> Str
    fun get_suffix str size;

    of Str -> Int -> Str fun cut_suffix str shrink;
    # Returns a shortened substring, the final length is >= 0

}


fun print_str id = print("%.*s\n", id->size, id->data);


fun mk_str raw_string = {
    of Str var s = { .data = raw_string,
                     .size = -1, };
    s.size = strlen(s);
    s
};


fun to_zero_terminated span = {
    var size = strlen(span);
    var result = (new [size + 1] Char) ~> _;
    memcpy(result, span.data, size);
    result[size] = '\0';
    result
};


fun strlen str = if str.size == -1
        strlen_inner(str.data, 0)
    else
        str.size
    ;

fun strlen_inner s len = {
    if *s == '\0' { return len; };
    strlen_inner(s + 1, len + 1)
};


fun cut_prefix str skip = {
    .data = str.data + skip,
    .size = { var len = strlen(str);
              if len > skip { len - skip } else 0 }
    };


fun get_suffix str size = cut_suffix(str, strlen(str) - size);


fun cut_suffix str shrink = {
    .data = str.data,
    .size = { var len = strlen(str);
              if len > shrink then len - shrink else 0 }
    };

